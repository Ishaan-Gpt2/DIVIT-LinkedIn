/*
  # Create Missing Database Tables

  1. New Tables
    - `ai_clones` - AI writing clones for users
    - `linkedin_posts` - LinkedIn posts generated by users
    - `connections` - LinkedIn connections and networking data
    - `automation_runs` - Track automation execution history
    - `api_usage` - Track API usage and credits
    - `user_settings` - User preferences and configuration

  2. Security
    - Enable RLS on all tables
    - Add policies for authenticated users to manage their own data

  3. Indexes
    - Add performance indexes for common queries
    - Foreign key relationships between tables
*/

-- Create ai_clones table
CREATE TABLE IF NOT EXISTS ai_clones (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  name text NOT NULL,
  description text,
  tone text NOT NULL,
  personality jsonb DEFAULT '[]'::jsonb,
  sample_posts jsonb DEFAULT '[]'::jsonb,
  is_active boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create linkedin_posts table
CREATE TABLE IF NOT EXISTS linkedin_posts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  clone_id uuid,
  content text NOT NULL,
  tone text,
  status text DEFAULT 'draft'::text,
  scheduled_for timestamptz,
  posted_at timestamptz,
  engagement jsonb DEFAULT '{}'::jsonb,
  ai_score integer,
  human_score integer,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create connections table
CREATE TABLE IF NOT EXISTS connections (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  name text NOT NULL,
  title text,
  company text,
  industry text,
  country text,
  avatar_url text,
  linkedin_url text,
  email text,
  phone text,
  status text DEFAULT 'pending'::text,
  match_score integer,
  response_rate integer,
  mutual_connections integer DEFAULT 0,
  notes text,
  sent_at timestamptz DEFAULT now(),
  connected_at timestamptz,
  created_at timestamptz DEFAULT now()
);

-- Create automation_runs table
CREATE TABLE IF NOT EXISTS automation_runs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  type text NOT NULL,
  status text DEFAULT 'running'::text,
  input_data jsonb DEFAULT '{}'::jsonb,
  output_data jsonb DEFAULT '{}'::jsonb,
  credits_used integer DEFAULT 0,
  error_message text,
  started_at timestamptz DEFAULT now(),
  completed_at timestamptz
);

-- Create api_usage table
CREATE TABLE IF NOT EXISTS api_usage (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  service text NOT NULL,
  endpoint text,
  credits_used integer DEFAULT 1,
  success boolean DEFAULT true,
  response_time_ms integer,
  created_at timestamptz DEFAULT now()
);

-- Create user_settings table if it doesn't exist
CREATE TABLE IF NOT EXISTS user_settings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL UNIQUE,
  notifications jsonb DEFAULT '{"push": true, "email": true, "marketing": false}'::jsonb,
  privacy jsonb DEFAULT '{"profile_visible": true, "activity_visible": false, "analytics_sharing": true}'::jsonb,
  automation jsonb DEFAULT '{"daily_limit": 20, "auto_connect": false, "personalize_messages": true}'::jsonb,
  api_keys jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add foreign key constraints
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'ai_clones_user_id_fkey'
  ) THEN
    ALTER TABLE ai_clones ADD CONSTRAINT ai_clones_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'linkedin_posts_user_id_fkey'
  ) THEN
    ALTER TABLE linkedin_posts ADD CONSTRAINT linkedin_posts_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'linkedin_posts_clone_id_fkey'
  ) THEN
    ALTER TABLE linkedin_posts ADD CONSTRAINT linkedin_posts_clone_id_fkey 
    FOREIGN KEY (clone_id) REFERENCES ai_clones(id) ON DELETE SET NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'connections_user_id_fkey'
  ) THEN
    ALTER TABLE connections ADD CONSTRAINT connections_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'automation_runs_user_id_fkey'
  ) THEN
    ALTER TABLE automation_runs ADD CONSTRAINT automation_runs_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'api_usage_user_id_fkey'
  ) THEN
    ALTER TABLE api_usage ADD CONSTRAINT api_usage_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'user_settings_user_id_fkey'
  ) THEN
    ALTER TABLE user_settings ADD CONSTRAINT user_settings_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;
END $$;

-- Add check constraints
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'linkedin_posts_status_check'
  ) THEN
    ALTER TABLE linkedin_posts ADD CONSTRAINT linkedin_posts_status_check 
    CHECK (status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'posted'::text, 'failed'::text]));
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'connections_status_check'
  ) THEN
    ALTER TABLE connections ADD CONSTRAINT connections_status_check 
    CHECK (status = ANY (ARRAY['pending'::text, 'connected'::text, 'declined'::text]));
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'automation_runs_status_check'
  ) THEN
    ALTER TABLE automation_runs ADD CONSTRAINT automation_runs_status_check 
    CHECK (status = ANY (ARRAY['running'::text, 'completed'::text, 'failed'::text]));
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'automation_runs_type_check'
  ) THEN
    ALTER TABLE automation_runs ADD CONSTRAINT automation_runs_type_check 
    CHECK (type = ANY (ARRAY['post_generation'::text, 'auto_comment'::text, 'connection_search'::text, 'profile_scraping'::text]));
  END IF;
END $$;

-- Enable Row Level Security
ALTER TABLE ai_clones ENABLE ROW LEVEL SECURITY;
ALTER TABLE linkedin_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE automation_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for ai_clones
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'ai_clones' AND policyname = 'Users can manage own clones'
  ) THEN
    CREATE POLICY "Users can manage own clones"
      ON ai_clones
      FOR ALL
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;
END $$;

-- Create RLS policies for linkedin_posts
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'linkedin_posts' AND policyname = 'Users can manage own posts'
  ) THEN
    CREATE POLICY "Users can manage own posts"
      ON linkedin_posts
      FOR ALL
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;
END $$;

-- Create RLS policies for connections
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'connections' AND policyname = 'Users can manage own connections'
  ) THEN
    CREATE POLICY "Users can manage own connections"
      ON connections
      FOR ALL
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;
END $$;

-- Create RLS policies for automation_runs
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'automation_runs' AND policyname = 'Users can view own automation runs'
  ) THEN
    CREATE POLICY "Users can view own automation runs"
      ON automation_runs
      FOR SELECT
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'automation_runs' AND policyname = 'Users can insert own automation runs'
  ) THEN
    CREATE POLICY "Users can insert own automation runs"
      ON automation_runs
      FOR INSERT
      TO authenticated
      WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Create RLS policies for api_usage
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'api_usage' AND policyname = 'Users can view own API usage'
  ) THEN
    CREATE POLICY "Users can view own API usage"
      ON api_usage
      FOR SELECT
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'api_usage' AND policyname = 'Users can insert own API usage'
  ) THEN
    CREATE POLICY "Users can insert own API usage"
      ON api_usage
      FOR INSERT
      TO authenticated
      WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Create RLS policies for user_settings
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE tablename = 'user_settings' AND policyname = 'Users can manage own settings'
  ) THEN
    CREATE POLICY "Users can manage own settings"
      ON user_settings
      FOR ALL
      TO authenticated
      USING (auth.uid() = user_id);
  END IF;
END $$;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_ai_clones_user_id ON ai_clones(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_clones_active ON ai_clones(user_id, is_active);
CREATE INDEX IF NOT EXISTS idx_linkedin_posts_user_id ON linkedin_posts(user_id);
CREATE INDEX IF NOT EXISTS idx_linkedin_posts_status ON linkedin_posts(user_id, status);
CREATE INDEX IF NOT EXISTS idx_connections_user_id ON connections(user_id);
CREATE INDEX IF NOT EXISTS idx_connections_status ON connections(user_id, status);
CREATE INDEX IF NOT EXISTS idx_automation_runs_user_id ON automation_runs(user_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_user_id ON api_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_created_at ON api_usage(user_id, created_at);
CREATE INDEX IF NOT EXISTS idx_user_settings_user_id ON user_settings(user_id);

-- Create trigger function for updating updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at columns
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.triggers 
    WHERE trigger_name = 'update_ai_clones_updated_at'
  ) THEN
    CREATE TRIGGER update_ai_clones_updated_at
      BEFORE UPDATE ON ai_clones
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.triggers 
    WHERE trigger_name = 'update_linkedin_posts_updated_at'
  ) THEN
    CREATE TRIGGER update_linkedin_posts_updated_at
      BEFORE UPDATE ON linkedin_posts
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.triggers 
    WHERE trigger_name = 'update_user_settings_updated_at'
  ) THEN
    CREATE TRIGGER update_user_settings_updated_at
      BEFORE UPDATE ON user_settings
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  END IF;
END $$;